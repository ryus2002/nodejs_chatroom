# 即時聊天室進階功能實作指南 (Docker 環境)

這份指南將幫助新手開發者在 Docker 環境中實現即時聊天室的進階功能，包括端到端加密、語音/視訊聊天、聊天機器人整合等。

## 1. 設置 Docker 開發環境

### 步驟 1：安裝 Docker
首先確保您的系統已安裝 Docker 和 Docker Compose：
```bash
# 檢查 Docker 版本
docker --version

# 檢查 Docker Compose 版本
docker-compose --version
```

如果尚未安裝，請參考 [Docker 官方網站](https://docs.docker.com/get-docker/) 進行安裝。

### 步驟 2：創建基本的 Docker 配置

#### Dockerfile
```dockerfile
# 使用官方 Node.js 映像作為基礎
FROM node:16

# 設置工作目錄
WORKDIR /app

# 複製 package.json 和 package-lock.json
COPY package*.json ./

# 安裝依賴
RUN npm install

# 複製應用程式代碼
COPY . .

# 暴露端口
EXPOSE 3000

# 啟動命令
CMD ["npm", "start"]
```

#### docker-compose.yml
```yaml
version: '3'
services:
  # 聊天應用服務
  chat-app:
    build: .
    ports:
      - "3000:3000"
    volumes:
      - .:/app
      - /app/node_modules
    environment:
      - NODE_ENV=development
    depends_on:
      - mongo
      - redis

  # MongoDB 服務
  mongo:
    image: mongo:latest
    ports:
      - "27017:27017"
    volumes:
      - mongo-data:/data/db

  # Redis 用於會話管理和 Socket.IO 適配器
  redis:
    image: redis:latest
    ports:
      - "6379:6379"

volumes:
  mongo-data:
```

### 步驟 3：初始化項目
```bash
# 創建項目目錄
mkdir chat-app && cd chat-app

# 初始化 package.json
echo '{
  "name": "chat-app",
  "version": "1.0.0",
  "description": "Real-time chat application with advanced features",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js"
  },
  "dependencies": {
    "express": "^4.17.1",
    "socket.io": "^4.4.1",
    "crypto-js": "^4.1.1",
    "node-nlp": "^4.22.1",
    "mongoose": "^6.1.4",
    "redis": "^4.0.1",
    "socket.io-redis": "^6.1.1"
  },
  "devDependencies": {
    "nodemon": "^2.0.15"
  }
}' > package.json

# 創建 Docker 相關檔案
touch Dockerfile docker-compose.yml

# 啟動 Docker 容器
docker-compose up -d
```

## 2. 端到端加密：實現訊息加密功能

### 步驟 1：在 Docker 容器中安裝加密庫
```bash
# 進入 Docker 容器
docker-compose exec chat-app bash

# 安裝 crypto-js
npm install crypto-js
```

### 步驟 2：創建加密工具模組
```bash
# 在容器內創建檔案
mkdir -p src/utils
touch src/utils/encryption.js
```

### 步驟 3：實作加密功能
在 Docker 容器內編輯 `src/utils/encryption.js`:

```javascript
const CryptoJS = require('crypto-js');

class EncryptionService {
  constructor() {
    // 在實際應用中，應從安全的環境變數或密鑰管理服務獲取
    this.defaultKey = process.env.ENCRYPTION_KEY || 'default-secure-key';
  }

  // 加密訊息
  encrypt(message, key = this.defaultKey) {
    return CryptoJS.AES.encrypt(message, key).toString();
  }

  // 解密訊息
  decrypt(encryptedMessage, key = this.defaultKey) {
    const bytes = CryptoJS.AES.decrypt(encryptedMessage, key);
    return bytes.toString(CryptoJS.enc.Utf8);
  }

  // 生成隨機金鑰
  generateKey(length = 32) {
    return CryptoJS.lib.WordArray.random(length).toString();
  }
}

module.exports = new EncryptionService();
```

### 步驟 4：在 Docker 環境中整合到聊天應用
在容器內創建前端 JavaScript 檔案 `public/js/chat.js`:

```javascript
// 引入加密服務 (在實際前端應用中，這會透過 webpack 等工具處理)
const encryptionService = require('../../src/utils/encryption');

// 房間金鑰管理
let roomSecretKey = localStorage.getItem('roomKey') || null;
if (!roomSecretKey) {
  // 在實際應用中，這個金鑰應該通過安全的方式交換
  roomSecretKey = prompt('請輸入房間金鑰或創建新金鑰:');
  localStorage.setItem('roomKey', roomSecretKey);
}

// 發送加密訊息
function sendEncryptedMessage(socket, message, username) {
  const encryptedContent = encryptionService.encrypt(message, roomSecretKey);
  
  socket.emit('chat message', {
    content: encryptedContent,
    sender: username,
    timestamp: new Date()
  });
}

// 接收並解密訊息
function setupMessageReceiver(socket, messageContainer) {
  socket.on('chat message', (msg) => {
    try {
      const decryptedContent = encryptionService.decrypt(msg.content, roomSecretKey);
      
      // 顯示訊息
      const messageElement = document.createElement('div');
      messageElement.className = 'message';
      messageElement.innerHTML = `
        <span class="sender">${msg.sender}</span>
        <span class="content">${decryptedContent}</span>
        <span class="timestamp">${new Date(msg.timestamp).toLocaleTimeString()}</span>
      `;
      
      messageContainer.appendChild(messageElement);
      messageContainer.scrollTop = messageContainer.scrollHeight;
    } catch (error) {
      console.error('解密失敗，可能使用了錯誤的金鑰:', error);
    }
  });
}
```

## 3. 語音/視訊聊天：在 Docker 中整合 WebRTC

### 步驟 1：在 Docker 容器中安裝必要依賴
```bash
# 進入 Docker 容器
docker-compose exec chat-app bash

# 安裝 simple-peer (WebRTC 輔助庫)
npm install simple-peer
```

### 步驟 2：創建 WebRTC 服務
在容器內創建 `src/services/webrtc-service.js`:

```javascript
// 這個檔案將在服務器端處理 WebRTC 信令
const socketIo = require('socket.io');

class WebRTCService {
  constructor(server) {
    this.io = socketIo(server);
    this.setupSignaling();
  }

  setupSignaling() {
    this.io.on('connection', (socket) => {
      console.log('用戶連接: ', socket.id);
      
      // 加入特定房間
      socket.on('join-room', (roomId, userId) => {
        socket.join(roomId);
        socket.to(roomId).emit('user-connected', userId);
        
        socket.on('disconnect', () => {
          socket.to(roomId).emit('user-disconnected', userId);
        });
      });
      
      // 處理呼叫請求
      socket.on('call-user', (data) => {
        this.io.to(data.userToCall).emit('incoming-call', {
          signal: data.signalData,
          from: data.from,
          name: data.name
        });
      });
      
      // 處理呼叫接受
      socket.on('accept-call', (data) => {
        this.io.to(data.to).emit('call-accepted', data.signal);
      });
    });
  }
}

module.exports = WebRTCService;
```

### 步驟 3：在 Docker 中創建前端 WebRTC 實現
在容器內創建 `public/js/video-chat.js`:

```javascript
// 注意：在實際部署時，您需要使用構建工具如 webpack 來處理這些模組
const Peer = require('simple-peer');

class VideoChat {
  constructor(socket, localVideoElement, remoteVideoElement, username) {
    this.socket = socket;
    this.localVideo = localVideoElement;
    this.remoteVideo = remoteVideoElement;
    this.username = username;
    this.peers = {};
    this.localStream = null;
  }

  async init() {
    try {
      // 獲取本地媒體流
      this.localStream = await navigator.mediaDevices.getUserMedia({
        video: true,
        audio: true
      });
      
      // 顯示本地視訊
      this.localVideo.srcObject = this.localStream;
      
      // 設置信令處理
      this.setupSignaling();
      
      return true;
    } catch (err) {
      console.error('無法獲取媒體設備:', err);
      return false;
    }
  }

  setupSignaling() {
    // 處理來電
    this.socket.on('incoming-call', (data) => {
      this.answerCall(data);
    });
    
    // 處理對方接受通話
    this.socket.on('call-accepted', (signal) => {
      if (this.peers[signal.from]) {
        this.peers[signal.from].signal(signal.signal);
      }
    });
  }

  // 發起通話
  callUser(userId) {
    const peer = new Peer({
      initiator: true,
      trickle: false,
      stream: this.localStream
    });
    
    peer.on('signal', (signal) => {
      this.socket.emit('call-user', {
        userToCall: userId,
        signalData: signal,
        from: this.socket.id,
        name: this.username
      });
    });
    
    peer.on('stream', (remoteStream) => {
      this.remoteVideo.srcObject = remoteStream;
    });
    
    this.peers[userId] = peer;
  }

  // 接聽通話
  answerCall(data) {
    const peer = new Peer({
      initiator: false,
      trickle: false,
      stream: this.localStream
    });
    
    peer.on('signal', (signal) => {
      this.socket.emit('accept-call', {
        signal: signal,
        to: data.from
      });
    });
    
    peer.on('stream', (remoteStream) => {
      this.remoteVideo.srcObject = remoteStream;
    });
    
    peer.signal(data.signal);
    this.peers[data.from] = peer;
  }
  
  // 結束通話
  endCall(userId) {
    if (this.peers[userId]) {
      this.peers[userId].destroy();
      delete this.peers[userId];
    }
    
    // 清理視訊元素
    this.remoteVideo.srcObject = null;
  }
}

// 導出供 HTML 使用
window.VideoChat = VideoChat;
```

## 4. 聊天機器人：在 Docker 中整合

### 步驟 1：在 Docker 容器中安裝 NLP 庫
```bash
# 進入 Docker 容器
docker-compose exec chat-app bash

# 安裝 node-nlp
npm install node-nlp
```

### 步驟 2：創建聊天機器人服務
在容器內創建 `src/services/chatbot-service.js`:

```javascript
const { NlpManager } = require('node-nlp');

class ChatBotService {
  constructor() {
    this.manager = new NlpManager({ languages: ['zh'] });
    this.initialize();
  }

  async initialize() {
    // 添加基本訓練數據
    this.addTrainingData();
    
    // 訓練模型
    console.log('開始訓練聊天機器人...');
    await this.manager.train();
    console.log('聊天機器人訓練完成!');
  }

  addTrainingData() {
    // 問候語
    this.manager.addDocument('zh', '你好', 'greeting');
    this.manager.addDocument('zh', '嗨', 'greeting');
    this.manager.addDocument('zh', '早安', 'greeting');
    this.manager.addDocument('zh', '晚安', 'greeting');
    this.manager.addAnswer('zh', 'greeting', '你好！有什麼我能幫你的嗎？');
    this.manager.addAnswer('zh', 'greeting', '嗨！很高興見到你！');
    
    // 詢問天氣
    this.manager.addDocument('zh', '天氣如何', 'weather');
    this.manager.addDocument('zh', '今天會下雨嗎', 'weather');
    this.manager.addDocument('zh', '氣溫多少', 'weather');
    this.manager.addAnswer('zh', 'weather', '抱歉，我目前無法獲取天氣信息。');
    
    // 聊天功能相關
    this.manager.addDocument('zh', '如何加密訊息', 'encryption');
    this.manager.addDocument('zh', '訊息加密', 'encryption');
    this.manager.addDocument('zh', '安全聊天', 'encryption');
    this.manager.addAnswer('zh', 'encryption', '我們的聊天室使用端到端加密技術，確保只有您和對方能夠讀取訊息內容。');
    
    // 視訊聊天相關
    this.manager.addDocument('zh', '如何開始視訊通話', 'video');
    this.manager.addDocument('zh', '視訊聊天', 'video');
    this.manager.addDocument('zh', '語音通話', 'video');
    this.manager.addAnswer('zh', 'video', '點擊聊天室右上角的攝影機圖示，然後選擇您想要通話的用戶。');
    
    // 幫助指令
    this.manager.addDocument('zh', '幫助', 'help');
    this.manager.addDocument('zh', '使用說明', 'help');
    this.manager.addDocument('zh', '指令', 'help');
    this.manager.addAnswer('zh', 'help', '可用指令：\n- @bot 你好：打招呼\n- @bot 天氣：詢問天氣\n- @bot 加密：了解加密功能\n- @bot 視訊：了解視訊功能');
  }

  async processMessage(message) {
    if (!message.startsWith('@bot ')) {
      return null;
    }
    
    const query = message.replace('@bot ', '').trim();
    const response = await this.manager.process('zh', query);
    
    return {
      answer: response.answer || '抱歉，我不明白你的意思。試試輸入 "@bot 幫助" 獲取可用指令。',
      intent: response.intent,
      score: response.score
    };
  }
}

module.exports = new ChatBotService();
```

### 步驟 3：在 Docker 中整合到主服務器
在容器內修改 `server.js`:

```javascript
const express = require('express');
const http = require('http');
const socketIo = require('socket.io');
const path = require('path');
const mongoose = require('mongoose');
const redis = require('redis');
const { createAdapter } = require('@socket.io/redis-adapter');

// 導入自定義服務
const chatBotService = require('./src/services/chatbot-service');
const WebRTCService = require('./src/services/webrtc-service');

// 創建 Express 應用
const app = express();
const server = http.createServer(app);
const io = socketIo(server);

// 設置靜態文件
app.use(express.static(path.join(__dirname, 'public')));

// 連接到 MongoDB (使用 Docker 服務名稱)
mongoose.connect('mongodb://mongo:27017/chatapp', {
  useNewUrlParser: true,
  useUnifiedTopology: true
}).then(() => {
  console.log('已連接到 MongoDB');
}).catch(err => {
  console.error('MongoDB 連接錯誤:', err);
});

// 設置 Redis 適配器 (使用 Docker 服務名稱)
const pubClient = redis.createClient({ url: 'redis://redis:6379' });
const subClient = pubClient.duplicate();

Promise.all([pubClient.connect(), subClient.connect()]).then(() => {
  io.adapter(createAdapter(pubClient, subClient));
  console.log('已連接到 Redis 適配器');
});

// 初始化 WebRTC 服務
const webRTCService = new WebRTCService(server);

// 處理聊天訊息
io.on('connection', (socket) => {
  console.log('用戶連接:', socket.id);
  
  // 處理加入聊天室
  socket.on('join', (data) => {
    socket.join(data.room);
    socket.to(data.room).emit('user joined', {
      username: data.username,
      userId: socket.id
    });
  });
  
  // 處理聊天訊息
  socket.on('chat message', async (msg) => {
    const room = Array.from(socket.rooms)[1]; // 獲取用戶所在房間
    
    // 廣播訊息給房間內所有人
    io.to(room).emit('chat message', msg);
    
    // 檢查是否是發給機器人的訊息
    const botResponse = await chatBotService.processMessage(msg.content);
    if (botResponse) {
      io.to(room).emit('chat message', {
        content: botResponse.answer,
        sender: 'ChatBot',
        timestamp: new Date()
      });
    }
  });
  
  // 處理斷開連接
  socket.on('disconnect', () => {
    console.log('用戶斷開連接:', socket.id);
  });
});

// 啟動服務器
const PORT = process.env.PORT || 3000;
server.listen(PORT, () => {
  console.log(`服務器運行在 http://localhost:${PORT}`);
});
```

## 5. 完整的 Docker 部署流程

### 步驟 1：完善 Dockerfile
```dockerfile
# 使用官方 Node.js 映像作為基礎
FROM node:16

# 設置工作目錄
WORKDIR /app

# 複製 package.json 和 package-lock.json
COPY package*.json ./

# 安裝依賴
RUN npm install

# 複製應用程式代碼
COPY . .

# 設置環境變數
ENV NODE_ENV=production
ENV PORT=3000
ENV ENCRYPTION_KEY=your-secure-encryption-key

# 暴露端口
EXPOSE 3000

# 啟動命令
CMD ["node", "server.js"]
```

### 步驟 2：創建生產環境的 docker-compose.yml
```yaml
services:
  # 聊天應用服務
  chat-app:
    build: .
    restart: always
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - ENCRYPTION_KEY=your-secure-encryption-key
      - MONGO_URI=mongodb://mongo:27017/chatapp
      - REDIS_URI=redis://redis:6379
    depends_on:
      - mongo
      - redis

  # MongoDB 服務
  mongo:
    image: mongo:latest
    restart: always
    volumes:
      - mongo-data:/data/db
    ports:
      - "27017:27017"

  # Redis 服務
  redis:
    image: redis:latest
    restart: always
    volumes:
      - redis-data:/data
    ports:
      - "6379:6379"

  # Nginx 反向代理 (可選)
  nginx:
    image: nginx:latest
    restart: always
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/conf:/etc/nginx/conf.d
      - ./nginx/ssl:/etc/nginx/ssl
    depends_on:
      - chat-app

volumes:
  mongo-data:
  redis-data:
```

### 步驟 3：構建和部署
```bash
# 構建 Docker 映像
docker-compose build

# 啟動服務
docker-compose up -d

# 查看日誌
docker-compose logs -f
```

### 步驟 4：監控和擴展
```bash
# 檢查容器狀態
docker-compose ps

# 擴展服務 (如果需要)
docker-compose up -d --scale chat-app=3

# 檢查資源使用情況
docker stats
```

## 6. 常見問題與解決方案

### Docker 相關問題

1. **Q: 容器無法連接到 MongoDB 或 Redis**
   **A:** 確保在 Docker 環境中使用服務名稱而非 localhost，例如 `mongodb://mongo:27017` 而非 `mongodb://localhost:27017`。

2. **Q: Docker 容器啟動後立即退出**
   **A:** 檢查日誌 `docker-compose logs chat-app`，可能是代碼錯誤或依賴問題。確保 package.json 中的依賴都已正確安裝。

3. **Q: 如何在不重建映像的情況下更新代碼？**
   **A:** 在開發環境中，使用卷掛載：
   ```yaml
   volumes:
     - .:/app
     - /app/node_modules
   ```

### 應用功能問題

1. **Q: WebRTC 連接失敗**
   **A:** 在 Docker 環境中，可能需要配置 STUN/TURN 伺服器。添加以下代碼：
   ```javascript
   const peerConfig = {
     iceServers: [
       { urls: 'stun:stun.l.google.com:19302' },
       { urls: 'stun:stun1.l.google.com:19302' }
     ]
   };
   ```

2. **Q: 加密訊息無法解密**
   **A:** 確保所有用戶使用相同的加密金鑰，或實現安全的金鑰交換機制。在 Docker 環境中，可以通過環境變數設置默認金鑰。

3. **Q: 聊天機器人訓練時間過長**
   **A:** 考慮預先訓練模型並保存，然後在啟動時載入：
   ```javascript
   // 保存模型
   await this.manager.save('./model.nlp');
   
   // 載入模型
   await this.manager.load('./model.nlp');
   ```

## 7. 學習資源

1. **Docker 學習資源**:
   - [Docker 官方文檔](https://docs.docker.com/)
   - [Docker Compose 文檔](https://docs.docker.com/compose/)

2. **WebRTC 在 Docker 中的應用**:
   - [WebRTC.org 官方文檔](https://webrtc.org/)
   - [使用 Docker 部署 WebRTC 應用](https://github.com/peers/peerjs-server#docker)

3. **加密與安全**:
   - [Web Crypto API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API)
   - [Docker 安全最佳實踐](https://docs.docker.com/engine/security/security/)

4. **聊天機器人與 NLP**:
   - [NLP.js 文檔](https://github.com/axa-group/nlp.js)
   - [在 Docker 中部署 NLP 服務](https://towardsdatascience.com/deploy-nlp-model-in-docker-container-with-flask-restful-api-67efc9ed0a67)

希望這份指南能幫助您在 Docker 環境中成功實現即時聊天室的進階功能！如有任何問題，歡迎參考提供的學習資源或在社群中尋求幫助。